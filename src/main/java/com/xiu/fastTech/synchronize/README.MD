# Synchronized底层原理

	Synchronized可以保证方法或代码块运行时，同时只有一个方法可以进入临界区，它也可以保证共享变量内存可见性。
	普通同步方法，锁定的是当前实例对象
	静态同步方法，锁定的是类的class对象
	同步方法块，锁的是括号里面的对象（可能是class对象，也可能是实例对象）
	
## 实现
	
	当一个线程访问同步代码块时，首先需要获取到锁，才能执行同步代码块，执行完或者抛出异常时，释放锁。
	com.xiu.fastTech.synchronize.SynchronizedTest.java中注释的地方，是通过javap工具查看的字节码信息。
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/synchronize/image/monitorenter.jpg)
	
	同步块是使用monitorenter和monitorexit指令实现的。
	而同步方法是依靠方法修饰符ACC_SYNCHRONIZED实现的。
	
## 同步块的实现依靠monitorenter与monitorexit指令

	monitorentor指令插入到同步代码块开始的地方，monitorexit指令插入到同步代码块结束的位置，JVM保证每个monitorenter有一个monitorexit对应。
	任何对象都有一个Monitor与之相关联，当一个Monitor被持有后，处于锁定状态。线程执行到monitor指令时，尝试获取对象所对应的Monitor所有权，即获取对象锁。
	同一时刻只有一个线程能够成功，失败的线程会被阻塞，放入同步对列，进入阻塞状态。	
	
### monitorenter指令执行步骤

	每个对象都有一个监视器，该监视器被占用时是锁定状态，因此获取到监视器也就是获取到同步锁。线程执行monitorenter指令时会尝试获取监视器的所有权：
	1.若该监视器进入次数为0，该线程进入监视器会将次数设置1，此时该线程获取到锁
	2.若线程已经占有该监视器，则进入次数+1
	3.若其他线程已经占有该监视器，则线程被阻塞直到监视器进入次数为0，之后线程间会竞争获取该监视器所有权。
	4.只有首先获取到锁的线程才允许继续获取多个锁
	
### monitorexit执行执行步骤

	1.执行monitorexit指令的线程必须是对象实例对应的监视器所有者
	2.执行指令时，线程先将进入次数-1，如果-1后变成0，则线程退出监视器，即释放锁
	3.其他阻塞在该监视器的现场可重新竞争该监视器的所有权

	
## 同步方法的实现依靠ACC_SYNCHRONIZED
	通过方法调用指令检查该方法在常量池中是否包含ACC_SYNCHRONIZED标记符，如果有,JVM要求线程调用前请求锁
	
# Monitor Object模式（监视器）

![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/synchronize/image/monitorrecord.jpg)

	当一个线程访问同步代码块时，首先在Entry-set 排队。如果没有其他线程等待，当前线程获取锁，继续执行同步代码块。如有有其他线程排队，必须在Entry-set排队，
	当有线程退出监视器时，所有线程参与锁竞争，只有一个线程可竞争成功得到锁。

	Monitor是一种同步工具，一种同步机制，是一个对象，具有互斥和信号机制的特性。
	互斥：一个Monitor锁在同一时刻只能被一个线程占用
	信号机制：占用Monitor锁失败的线程会暂时放弃竞争并等待某个谓词成真（条件变量），条件成立后，当前线程会通过释放锁通知正在等待这个条件变量的其他线程，让其重新竞争锁。
## Monitor Object模式中，有4种类型参与者：
	1.监视器对象（Monitor Object）:负责定义公共的接口方法，这些公共接口方法可在多线程中被调用
	2.同步方法：
	3.监视锁：（Monitor Lock）每个监视者对象拥有一把监视锁
	4.监视条件：(Monitor condition)同步方法使用监视锁和监视条件决定方法是否需要阻塞或重新执行。
## Monitor Object 模式协作过程：
	1.同步方法调用和串行化：
	客户线程调用监视者对象的同步方法时，必须获取它的监视锁
	只要监视器对象有其他同步方法被执行，获取操作就不会成功
	当监视器对象被线程占用时，客户线程被阻塞知道它获取监视锁
	当客户线程成功获取监视锁后，进入临界区，执行同步方法
	一旦同步方法执行完成，监视锁被自动释放，其他客户线程有机会调用执行该监视器对象的同步方法
	2.同步方法挂起
	如果调用同步方法的客户线程被阻塞，它能在监视条件上等待，这导致客户线程暂时释放监视锁，被挂起在监视条件上
	3.监视条件通知
	一个客户线程能够通知一个监视条件，目的是通知阻塞在该监视条件的线程恢复运行
	4.同步方法线程恢复：
	一旦一个早先被挂起在监视条件的同步方法线程获取通知，它将继续在最初的等待见识条件点上执行
	在被通知线程被允许恢复执行同步条件之前，监视锁自动被获取（线程间自动竞争锁）	
	
## Monitor保证了java多线程间共享变量时的同步机制

	一旦一个线程进入监控器，其他线程必须等待，直到这个线程退出。通过这种方式，一个监控器可以保证共享资源在同一时刻只可被一个线程使用，这种方式称为同步
	一旦一个线程进入一个实例的任何同步方法，别的线程不能进入该同一实例的其他同步方法，但可以进入非同步方法





	
	
	
	
	
	
	
	
	
	
	
	
	
	
