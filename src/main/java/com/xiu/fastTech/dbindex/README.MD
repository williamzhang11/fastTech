# 数据库索引原理

	B+树索引是数据库B+树在数据库中的一种实现，是数据库中最频繁使用的索引。B+树的B代表平衡（balance）.B+树是由二叉查找树，平衡二叉树，平衡多路查找树（B树）
	优化来的。
## 二叉查找树
	二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树
	二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。 
	如下图所示就是一棵二叉查找树， 
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/binarysorttree1.jpg)

	对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次

	二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造： 
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/binarysorttree2.jpg)	

	但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。
	
## 平衡二叉树（AVL Tree）
	平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，
	它的任何节点的两个子树的高度差<=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1； 
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/avl.jpg)	

## 平衡多路查找树（B-Tree）
	B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。
	
	系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
	
	InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，
	可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：
	
```
mysql> show variables like 'innodb_page_size';
```
	而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。
	InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
	B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/btree.jpg)		

	每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
	两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于
	17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。
	
	模拟查找关键字29的过程：
	
	根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
	比较关键字29在区间（17,35），找到磁盘块1的指针P2。
	根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
	比较关键字29在区间（26,30），找到磁盘块3的指针P2。
	根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
	在磁盘块8中的关键字列表中找到关键字29。
	分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。
	而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。
	
## B+Tree

	B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
	
	从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，
	如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大
	，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
	而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
	
	B+Tree相对于B-Tree有几点不同：
	
	非叶子节点只存储键值信息。
	所有叶子节点之间都有一个链指针。
	数据记录都存放在叶子节点中。
	将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/bplus.jpg)	
	通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。
	因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
	
	可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
	
	InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，
	也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。
	也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
	
	实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的
	，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。
	
	数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图
	在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助
	索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，
	InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
	
	
## B+树与B树区别
	1.B树种的同一键不会出现多次，可能在叶子节点上也可能在非叶子节点上； 
		b+树的键一定会出现在叶子节点上，同时也可能在非叶子节点上重复出现。 
		简单的说，b+树的非叶子节点存储的都是键值，键值对应的具体数据都存储在叶子节点上。
	2.b数据的每个节点存储的是真是数据，会导致每个节点的存储的数据量变小，所以整个b树的高度会相对变高。随着数据量的变大，维护代价也增加； 
		b+树的非叶子节点只存储的是键值，相对而言，一个非叶子节点存储的记录个数要比b树多的多。 b+树是横向扩展，随着数据增加，会变成一个矮胖子，
		b树是纵向扩展，最终树的高度越来越高（高瘦子）。
	3.b树的查询效率与键在b树的位置有关系，在叶子及诶单的时候最大复杂度与b+树相同；b+树复杂度对某个建成的树是固定的。
	4.b树的键的位置不固定并且整个树结构中只出现一次，是的增删改查操作复杂度增加；b+树种，非叶子节点对于叶子节点来说就像一个索引，
		增删改的时候只要找到键值（索引）的位置，再一层层的向下找即可，只有在遇到一个节点存储满了会对b+树分裂。
	5.b树种所有的数据都只存储一份；b+树除存储了所有数据的叶子节点外，还有之存储键值数据的非叶子节点。所以，b+树比b树会多占存储空间，
		多占的空间就是b+树的非叶子节点的所有空间。
## 主索引
	一个表可以建立多个索引，但每一个表都有一个存储所了有数据的索引。聚簇索引在每个表中只有一个，且是建立在主键上面的，
	这个主键包含的列可以是被隐藏的rowid列，也可以是自增	列，还可以被明确定义为不含NULL值的组合列等。称为聚簇索引、聚集索引

## 二级索引
	也称为：辅助索引
	唯一索引、普通索引、前缀索引等都是二级索引（辅助索引）
	二级索引存储的是记录的主键以及索引列值，而不是数据存储的地址。
	所谓回表就是在使用二级索引时，因为二级索引之存储了部分数据，如果根据键值查找到的数据不能包括全部目标数据，就需要二级索引指针，
	也就是键值对中的值，来找到聚簇索引的所有数据，然后根据完整的数据取出所需要列的过程。 覆盖索引不需要回表
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/index.jpg)	

		主键是采用B+Tree的数据结构（请看左图），根据上文可以知主键为聚簇索引，物理存储是根据ID的增加排序递增连续存储的。
		
		普通索引K也是B+Tree的数据结构（请看右图），但是它不是聚簇索引，因此为非聚簇索引或者辅助索引（聚簇索引只可能是主键，
		或者所有组成唯一键的所有列都为NOT NULL的第一个唯一索引，或者隐式创建的聚簇索引这三种情况）。
		他的叶子节点存储的是索引列的值，它的数据域是聚簇索引即ID。
		
		假如普通索引k为非唯一索引，要查询k=3的数据。
		需要在k索引查找k=3得到id=30。
		然后在左侧的ID索引树查找ID=30对应的记录R3。
		然后K索引树继续向右查找，发现下一个是k=5不满足（非唯一索引后面有可能有相等的值，因此向右查找到第一个不等于3的地方），停止。
		整个过程从K索引树到主键索引树的过程叫做“回表”。

	参考https://blog.csdn.net/u013235478/article/details/50625677
	http://blog.codinglabs.org/articles/theory-of-mysql-index.html
	总结：
	1.主键索引（聚餐索引）查询效率比非主键索引查询效率更高。如果能使用主键查找的，就尽量使用主键索引进行查找。
	2.主键定义的长度越小，二级索引的大小就越小，这样每个磁盘块存储的索引数据越多，查询效率就越高。
	3.用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，
	非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整
	
## InnoDB和MyISAM下存储引擎的索引区别

### MyISAM索引实现
	MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/myisam1.jpg)	
	这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。
	在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。
	如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/myisam2.jpg)

	同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，
	如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
	MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。
### InnoDB索引实现
	虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

	第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
	而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，
	因此InnoDB表数据文件本身就是主索引。
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/innodb1.jpg)

	图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集
	，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键
	，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
	
	第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为
	data域。例如，图11为定义在Col3上的一个辅助索引：
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dbindex/image/innodb2.jpg)

	这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：
	首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
	











































