# 类加载机制

## 1.作用

类加载器本身作用就是用于加载类的，将类转换成java.lang.Class的实例。类加载器是通过类
的全限定名来获取类的二进制字节流进而实现加载类。

当我们比较两个类是否相等的时候，首先必须要确认是否由同一个类加载器加载，否则就算是使用相
同class文件，被不同加载器加载比较结果还是不相等的。

## 2.有哪些类加载器

1.启动类加载器Bootstrap ClassLoader

启动类加载器该加载器由jvm控制，没有父类加载器，也没有子类加载器。

专门加载<JAVA_HOME>\lib下或者-Xbootclasspath参数指定的路径下的类库，

加载到jvm的内存中去。该类加载器使用c++语言实现，是虚拟机自身实现的一部分

2.扩展类加载器 ExtClassLoader

扩展类加载器由sun.misc.Launcher$ExtClassLoader类加载器实现。

专门加载<JAVA_HOME>\lib\ext或者java.ext.dirs系统变量指定路径的类库；


3.应用程序类加载器 AppClassLoader

类加载器由sun.misc.Launcher$AppClassLoader实现。

专门加载类路径Classpath上指定的类库。（就是项目bin目录下的class文件）。

4.CustomClassLoader 用户自定义类加载器

对于用户自定义的加载器，不管你是直接实现ClassLoader,还是继承URLClassLoader,
或者其他的子类。它的父类加载器都是AppClassLoader

## 父类委托机制(双亲委托机制)

1.  当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。
每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。

2.  当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略
，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp ClassLoader.

3.  当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次
有加载请求的时候直接返回。


好处：
因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。
考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的ClassLoader。




