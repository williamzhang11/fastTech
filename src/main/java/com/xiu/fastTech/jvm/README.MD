# Jvm

## jvm内存区域
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/jvm/image/jvmmemorymodel.jpg)

## 程序计数器
	虚拟机中没有使用CPU的程序计数器，而且在内存中模拟CPU的程序计数器。每一条线程都有一个独立的程序计数器。虚拟机中的程序计数器指向
	正在执行的字节码地址。
## java虚拟机栈
	java虚拟机栈也是线程私有的，每个方法执行时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直到执行完成
	都对应着一个栈帧在虚拟机中入栈到出栈过程。
## 本地方法栈
	本地方法栈与虚拟机栈区别在于，虚拟机栈为执行java方法服务，本地方法栈为虚拟机使用Native方法服务。
## java堆内存
	java堆是被所有线程共享的一块区域，在虚拟机启动时创建。用来存放对象实例，几乎所有对象实例都会在这里分配内存。堆是垃圾收集器管理的主要区域。
	垃圾收集器实现对象的自动销毁。java堆物理上是不连续的内存空间，逻辑上是连续的。
## 方法区
	是所有线程共享。主要用于存储类的信息，常量池，方法数据，方法代码。
	
## 方法区和永久代

	虚拟机规范中只规定了有方法区这个概念和它的作用，并没有规定如何去实现它。HotSpot jvm是用永久代实现方法区。
		jdk1.7以前可用
	 		-XX:PermSize 调整方法区初始大小
	 		-XX:MaxPermSize 调整方法区最大大小
	 	jdk1.7中存储在永久代的部分数据转移到了Java Heap或NativeHeap，并没有完全移除
		jdk1.8中移除了永久代，用元空间代替
			-XX: MetaspaceSize 元空间初始大小
			-XX: MaxMetaspaceSize元空间最大大小
	元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过最大的区别是：元空间不在虚拟机中
	而是使用本地内存
## 元空间替换永久代的原因：
	1.字符串存在永久代中，容易出现性能问题和内存溢出
	2.类及方法的信息等比较难确定其大小，因此对永久代的大小指定比较困难。太小容易出现永久代溢出，太大容易导致老年代溢出
	3.永久代会为GC带来不必要的复杂度，回收效率偏低
## 堆内存
	堆内存=新生代+老年代
	新生代分为3个区域，一个Eden区和2个Survivor区，它们之间的默认比例为（8：1：1），可修改。
	对象创建时主要分配在新生代的Eden区，少数情况下可直接分配在老年代（新生代空间不够时）。
	JVM每次使用新生代中的Eden和其中一块Survivor.在经过一次MinorGC后，将Eden和Survivor中还存活
	的对象一次性复制到另一Survivor空间（复制算法进行GC）最后清理掉Eden和刚才用到的Survivor空间
	此时在Survivor空间存活下来的对象的年龄设置为1，以后这些对象每在Survivor区熬过一次GC,它们的年龄加1
	，当对象达到某个年龄（默认15）时，把它们移到老年代。
   	新生代区与老年代比例为1：2
## 堆内存垃圾回收方式
	java堆是GC垃圾回收的主要区域，采用分代垃圾回收方式，GC分为2种：MinorGC，FullGC
### Minor GC（新生代垃圾回收方式）
	触发Minor GC(新生代GC)的情况：
		1.Eden区域满了
		2.新创建的对象大小大于Eden区域所剩余大小
	触发Full GC的情况：
		1.直接调用System.gc
		2.老年代空间不足时（可能是大对象创建，新生代存活下来对象转入引入的）
			策略：1.尽量做到让对象在Minor GC阶段回收
				2.不要创建大对象
		3.方法区空间不足（系统中要加载的类，反射类，调用方法多导致）
			策略：增大方法区
				转为使用CMS GC
		4.Minor GC时，survivor放不下，对象只能放入老年代，而老年代也放不下
			策略：增加survivor space，老年代空间
		5.

	
























	
	
	
	
	
	
	
	
