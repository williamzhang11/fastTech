# Jvm

## jvm内存模型
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/jvm/image/jvmmemorymodel.jpg)

## 程序计数器
	虚拟机中没有使用CPU的程序计数器，而且在内存中模拟CPU的程序计数器。每一条线程都有一个独立的程序计数器。虚拟机中的程序计数器指向
	正在执行的字节码地址。
## java虚拟机栈
	java虚拟机栈也是线程私有的，每个方法执行时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直到执行完成
	都对应着一个栈帧在虚拟机中入栈到出栈过程。
## 本地方法栈
	本地方法栈与虚拟机栈区别在于，虚拟机栈为执行java方法服务，本地方法栈为虚拟机使用Native方法服务。
## java堆
	java堆是被所有线程共享的一块区域，在虚拟机启动时创建。用来存放对象实例，几乎所有对象实例都会在这里分配内存。堆是垃圾收集器管理的主要区域。
	垃圾收集器实现对象的自动销毁。java堆物理上是不连续的内存空间，逻辑上是连续的。
## 方法区
	是所有线程共享。主要用于存储类的信息，常量池，方法数据，方法代码。
	
## 方法区和永久代

	虚拟机规范中只规定了有方法区这个概念和它的作用，并没有规定如何去实现它。HotSpot jvm是用永久代实现方法区。
		jdk1.7以前可用
	 		-XX:PermSize 调整方法区初始大小
	 		-XX:MaxPermSize 调整方法区最大大小
	 	jdk1.7中存储在永久代的部分数据转移到了Java Heap或NativeHeap，并没有完全移除
		jdk1.8中移除了永久代，用元空间代替
			-XX: MetaspaceSize 元空间初始大小
			-XX: MaxMetaspaceSize元空间最大大小
	元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过最大的区别是：元空间不在虚拟机中
	而是使用本地内存
## 元空间替换永久代的原因：
	1.字符串存在永久代中，容易出现性能问题和内存溢出
	2.类及方法的信息等比较难确定其大小，因此对永久代的大小指定比较困难。太小容易出现永久代溢出，太大容易导致老年代溢出
	3.永久代会为GC带来不必要的复杂度，回收效率偏低
	
	
	
	
























	
	
	
	
	
	
	
	
