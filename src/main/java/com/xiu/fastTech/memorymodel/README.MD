# java内存结构与内存模型
## java内存结构
	java内存结构，即jvm执行java程序过程中(运行时)，把其管理的内存划分为几个不同的内存区域

![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/memorymodel/image/memorystructure.jpg)

	1.方法区
	方法区存放类自身的各种信息，即Class对象的信息（方法信息，Field信息，类名称，类中静态变量，类中定义为final类型的变量）。该区域是被java线程共享
	而且存储的信息比较稳定，不会频繁GC，它属于堆中永久代，但jdk8之后永久代被移除。方法区也会内存溢出：java.lang.OutOfMemoryError: PermGen space
	常量池也是属于此区域，存储了字符串，final变量值，类名和方法名常量。常量池在编译期间就被确定了，保存在.class文件中。
	2.栈区
	该区主要是为执行方法服务的
	java栈是线程私有的结构，每创建一个线程都会创建对应的java栈，栈中包含多个栈帧，调用一个方法就会创建一个栈帧，新创建的
	栈帧在java栈的栈顶，栈顶的栈帧也称为活动栈。也就是当前正在执行的方法，程序计数器也会记录当前位置。栈帧包含局部变量，
	操作栈，方法返回值等信息。栈帧中指令执行完就会出栈。
	如果线程中栈的深度超过JVM规定的，也会出现抛出异常StackOverflowError和OutOfMemoryError。
	3.本地方法栈区
	该区和栈区作用是一样的，区别是java栈区为jvm执行方法服务的，而本地方法栈区为执行Native方法。也会出现抛出异常StackOverflowError和OutOfMemoryError。
	4.堆区
	是JVM中内存最大的一块区域。被所有线程共享。该区域存储java对象。所有的对象实例和数组都在堆区分配。该区也是GC（垃圾回收器）
	管理的主要区域。java堆分为新生代和老年代，其中新生代又分为Eden区域，From Survivor区，To Survivor区。
	5.程序计数器区
	程序计数器区，也叫PC寄存器。用于保存当前正在执行程序的内存地址。多线程交叉执行时，被中断的线程执行的内存地址就需要保存下来，以便于恢复执行时，从中断的指令地址
	继续执行。因此每个线程中都有个相互独立，且独立存储的的程序计数器，在此区存储。

## java内存模型

### 由来
	1.存在的CPU和缓存一致性问题：
	在程序运行过程中，会将需要的数据从主存（物理内存）复制到CPU高速缓存中，CPU计算时直接从高速缓存读取数据，写入数据，运算结束后，
	才将高速缓存中的数据刷新到主存中。这种方式在单线程下是没有任何问题的，但在多线程环境中出现线程安全问题。如2个线程分别读入某个变量初始值0，线程1进行+1操作后，把最新的值1写入内存，
	但线程2高速缓存中值还是0，进行+1操作，线程2的值还是1，然后写入内存。最终结果还是1，不是2.
	有2个种解决方法
	（1）通过在总线上加Lock锁：存在的问题是锁住总线期间，其他CPU无法访问内存，效率低
	（2）通过缓存一致性协议：核心思想是，当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量副本，会发出信号通知其他CPU将该变量的
		缓存设置为无效状态，当其他CPU需要读取该变量时，发现自己缓存的变量是无效的，它将从内存重新读取。
		
	2.并发编程时遇到的的三个问题：原子性，可见性，有序性问题。
	(1)原子性：一个操作或多个操作，要么全部执行，并且执行过程中，不能被打断，要么不执行。
		对大多数基本类型的变量的读写都是原子的。但在32位的JVM中对64位的long和double的读写不是原子的，是分2次进行的。
	(2)可见性：一个线程对共享变量修改后，其他线程也可以看到该变量的修改。
	java内存模型是通过一个线程在工作内存中变量修改后的值同步到主内存，另一个线程在读变量前从主内存刷新到工作内存中的方式实现的。
	可以通过volatile，synchronized,Lock，final都可以保证可见性
	
	有序性：程序执行的顺序按照代码的先后顺序执行
	
	
	上面的缓存一致性问题其实也是可见性问题，处理器的优化导致原子性问题，指令重排序导致有序性问题。
	因此为了解决这几个并发编程中的问题，就出现了内存模型。采用的方式主要时：限制处理器优化，使用内存屏障。
	
### java内存模型（JMM）
	java内存模型是JVM中定义的一种规范,目的是解决由于多线程通过共享内存进行通信时，存在的原子性，可见性，有序性问题。
	规定了：
	所有的变量都存储在主内存，每个线程有自己的工作内存，线程的工作内存保存该线程使用到变量主内存的副本拷贝。线程对变量的所有操作
	必须在工作内存进行，不能直接读写主内存中的变量。
	不同线程之间也无法直接访问对方工作内存变量，线程之间值的传递通过主内存进行。
	![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/memorymodel/image/jmm.jpg)
	
	线程1和线程2进行数据交换：
	1.线程1把工作内存中的更新过的共享变量刷新到主内存中去
	2.线程2到主内存读取线程1刷新过的共享变量，复制一份到自己的工作内存。
	
	并且java内存模型也提供了多线程环境中解决原子性，可见性，有序性问题的解决方案
	
#### java内存模型提供的解决方案
	有2种解决方案：一种是提供的各种关键字，另一种是happens-before原则。
	原子性问题：可以使用JVM自身提供的基本数据类型读写操作。对方法级别或代码块级别可使用synchronized关键字或重入锁ReentrantLock
	可见性问题：使用synchronized关键字，volatile关键字，或ReetrantLock锁
	对于指令重排序导致的可见性问题和有序性问题：可利用volatile关键字
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	













