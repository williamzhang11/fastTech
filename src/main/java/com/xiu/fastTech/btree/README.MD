# B树，B+树知识点

对于内存中查找结构，红黑树的效率已经非常好了，但是对于数据量非常大查找，全部放进内存中是不太可能的。必须在磁盘上建好红黑树结构，这种情况下红黑树不是一个很好的选择。
在磁盘中组织查找结果，从任何一节点指向其他节点都有可能读取一次磁盘数据，再将数据写入内存比较。频繁io操作效率是很低的。因此二叉树查找结构在磁盘中是很低效的。
## B树
	B树是平衡的多路查找树（有多个查找路径，不止2个），是一种平衡的多叉树，因为B树是平衡树，每个节点到叶子节点的额搞定都是相同的，这样保证B树的查询是稳定的。
	与二叉树相比，B树利用多个分支节点，减少获取记录时所经历的节点数，从而达到节省存取时间的目的。
	
## B树特点：
	1.关键字集合分布在整棵树中
	2.任何一个关键字且只出现在一个节点
	3.搜索可能在非叶子节点结束
	4.其搜索性能等价于在关键字全集内做一次二分查找
	5.每个节点关键字增多了，特别是应用在数据库中时
	6.所有叶子节点都在同一层
	
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/btree/image/btree.jpg)
	
	数据库充分利用磁盘块的原理（磁盘数据的存储采用块的形式进行存储，每块大小一般是4k,每次取数据时，取出这个4k的大小，每次io时，同一磁盘块的数据一次性提取出来）。
	把树的关键字增多后，树的层级比原来二叉树的层级少了，这样可以减少数据查找的次数，降低复杂度
	
## B树性能分析
	1.查找
	B树是一个平衡的多路查找树。B树的查找分2种：一种是从一个节点查找另一个节点的地址，需要定位磁盘地址（查找地址）查找代价极高。
	另一种将节点中的有序关键字放入内存，进行优化查找（二分查找），而B树的高度很小，比任何二叉结构查找树的效率高。
	2.插入
	B树插入会发生节点分裂操作。当插入引起s个节点分裂时，磁盘访问次数为h（读取搜索路径上的节点）+2s（回写2个分裂出的新节点）+1（回写新的根节点或插入后没有导致分裂的节点）
	因此需要访问磁盘的次数h+2s+1，最多可达3h+1。插入代价比较大
	3.删除
	B树的删除会发生节点合并。最坏情况下磁盘访问次数是3h=（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读当问）+（在第3至h层的合并需要h-2次写访问）+
	（对修改过的根节点和第2层的2个节点进行3次访问）
	
	但由于考虑磁盘存储结构，B树的查找，删除，插入代价远远小于任何二叉树（读写磁盘次数降低）
	
## B+树

	B+树实在B树基础上的优化，其更适应存储索引结构。
	B树机构中，每个节点不仅包括数据的key值，也包括data值，而每一页的存储空间都有限，如果data数据较大时，会导致每一页存储的key比较少，当存储数据量比较大时，同样导致B树查询深度很	大，增加磁盘IO次数，影响查询效率。
	B+树中，非叶子节点上只存储key信息，可以加大每一页中存储key的数量，进一步降低B+树的高度。

## B+树特点
	1.非叶子节点只存储key信息，而B树每个节点包含了数据
	2.所有叶子节点间有一个链指针
	3.B+树的非叶子节点只进行数据的索引，不会存实际的关键字记录指针，所有的数据地址必须到叶子节点才能获取到，所以每次查询的次数是一样的。
	4.B+树的高度一般为3
	
	![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/btree/image/bplustree.jpg)
	
## B+树的性能
	1.查找
	相同数量待查数据下，B+树查找过程中需要调用的磁盘IO操作少于普通B树。查找性能更好
	B+树查找效率更加稳定，因为所有叶子节点都在同一层，而且查找所有关键字必须走完从根节点到叶子节点的全部历程。因此同一颗B+树，任何关键字查找比较的次数都是一样的。
	而B树可能查找到某个非叶子节点就结束了。
	2.插入，删除
	B+树与B树在插入，删除的性能上是差不多的
	
	因此在文件结构存储中，B+树的应用要更多，效率也高于B树
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	