# 数据库锁

![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dblock/image/sqllock.JPG)

## 数据库中隐式设置的锁
	1.对于update,delete,insert语句，innodb自动给涉及数据集加排他锁（X）
	2.而MyISAM在执行查询语句select前，会自动给涉及的表加读锁，在执行更新操作（update,
		delete,insert）前，自动给涉及的表加写锁。myisam并不支持事务，同时锁也是表锁，
		因此不会出现死锁的情况

	从锁的粒度，可分为2大类：
	1.表锁
		开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度低
	2.行锁
		开销大，加锁慢；会出现死锁；锁定力度小，发生所冲突概率低，并发度高
		
	不同存储引擎支持的锁粒度不一样：
	1.Innodb行锁，表锁都支持
	2.myisam只支持表锁
	
	InnodDB只有通过索引条件检索数据才使用行级锁，否则，innodb使用表锁
	因此innodb行锁是基于索引的。
	
## 表锁
	表锁分为2种模式
	表读锁（Table Read Lock）
	表写锁（Table Write Lock）
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dblock/image/tablelock.JPG)

	上图可看到表读锁和表写锁环境下：读读不阻塞，读写阻塞，写写阻塞
	
	读读不阻塞：当前用户在读数据，其他用户也在读数据，不会加锁
	读写阻塞：当前用户在读数据，其他用户不能修改当前用户读的数据，会加锁
	写写阻塞：当前用户在修改数据，其他用户不能修改当前用户正在修改的数据，会加锁
	
	如果某个线程想获取读锁，另一个进程想获取写锁，mysql里写锁优于读锁
	
## 行锁
	Mysql种一般使用InnoDB存储引擎，它与MyISAM有2个本质区别
		InnoDB支持行锁
		InnoDB支持事务
	很少手动加表锁，即使innodB不走索引，加表锁也是自动的
	InnoDB实现2种类型的行锁
	共享锁（S锁）：允许多个事务去读一行
		也叫读锁：读锁是共享的，多个事务可同时读取同一个资源，但不允许其他事务修改
	排他锁（X锁）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
		也叫写锁：写锁会阻塞其他写锁和读锁
	
	为了允许行锁和表锁共存，实现多粒度锁机制，innoDB还有2种内部使用的意向锁，这2种意向锁都是表锁
	意向共享锁（IS）:事务打算给数据行加共享锁，必须先取得该表IS锁
	意向排他锁（IX）:事务打算给数据行加排他锁，必须取得该表的IX锁
	
	
	InnoDB有三种行锁的算法
	
	1，Record Lock：单个行记录上的锁。
	2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。
	3，Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。
	
	
## MVCC和事务隔离级别

	InnoDB提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。该方法是通过InnoDB的一个特性：MVCC来实现的
	
	数据库事务有不同的隔离级别，不同隔离级别对锁的使用是不同的，锁的应用导致不同事务的隔离级别
	事务的隔离级别是通过锁的机制实现，只不过隐藏加锁细节。
	数据库中的锁以及mvcc（多版本并发控制），是数据库并发控制的手段，为了提高并发性能
	
	表锁中读写是阻塞的，基于并发性能的考虑，MVCC一般读写是不阻塞的，因此MVCC很多情况下避免了加锁操作
	
	mvcc实现的读写不阻塞：多版本并发控制--》通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照
	提供一定级别（语句级或事务级）的一致性读取，从用户角度看，好像是数据库可以提供同一数据的多个版本。
	
	快照有2个级别：
	语句级（针对Read committed隔离级别），事务级别（针对Repeatable read隔离级别）
	
	1.Read uncommitted
	会出现脏读，不可重复读，幻读
	
	脏读：一个事务读取到另一个事务未提交的数据
	例子：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。
	A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。
	出现脏读的本质就是因为操作(修改)完该数据就立马释放掉锁，导致读的数据就变成了无用的或者是错误的数据。

	2.Read committed
	会出现不可重复读，幻读
	
	避免脏读的做法很简单：把释放锁位置调整到事务提交后，此时在事务提交前，其他进程无法对该行数据进行其他操作
	
	不可重复读：一个事务读取到另一个事务已经提交的数据，也就是一个事务可以看到其他事务的修改
	如：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样
	
	Read committed是语句级别的快照！每次读取的都是当前最新的版本
	
	3.Repeatable read
	会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！)
	
	Repeatable read避免不可重复读是事务级别的快照，每次读取的都是当前事务的版本。即使被修改了，也只会读取当前事务版本的数据
	
	幻读（虚读）：指在一个事务内读取到其他食物插入的数据，导致前后读取不一致
	注：和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致
	MySQL的Repeatable read隔离级别加上GAP间隙锁已经处理了幻读了。
	
	4.Serializable
	串行，避免以上的情况！
	
## 乐观锁和悲观锁
	无论是Read committed还是Repeatable read隔离级别，都是为了解决读写冲突的问题。
	单纯在Repeatable read隔离级别下我们来考虑一个问题
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dblock/image/updatelost.jpg)

	此时，用户李四的操作就丢失掉了。
	丢失更新：一个事务的更新覆盖了其他事务的更新结果。
	
	解决的方法：
	使用Serializable隔离级别，事务是串行执行的！
	乐观锁
	悲观锁
	
	悲观锁，就是很悲观，每次拿数据的时候，都认为别人会修改，每次在拿数据时都上锁，这样别人想拿这个数据就会block直到拿到锁。
	传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，
	都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，
	因此，在整个数据处理过程中，将数据处于锁定状态。
	只有冲突非常严重的系统才需要悲观锁。
	
	在select 语句后边加了 for update相当于加了排它锁(写锁)，加了写锁以后，其他的事务就不能对它修改了！需要等待当前事务修改完之后才可以修改.
	
	乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下
	在此期间别人有没有去更新这个数据，可以使用版本号等机制
	乐观锁适用于多读的应用类型，这样可以提高吞吐量。
	
![image](https://github.com/williamzhang11/fastTech/blob/master/src/main/java/com/xiu/fastTech/dblock/image/oplpck.jpg)

## 间隙锁GAP
	当使用范围条件检索数据，而不是相等条件检索数据，并请求共享或排它锁时，Innodb会符合范围条件的已有数据记录
	的索引加所，对于键值在条件范围内但不存在的记录，加间隙锁。
	
	间隙锁只会在Repeatable read隔离级别下使用。
	
	例子：假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101
	Select * from  emp where empid > 100 for update;
	上面是一个范围查询，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
	
	间隙锁的目的：
	1.为了防止幻读(上面也说了，Repeatable read隔离级别下再通过GAP锁即可避免了幻读)
	2.满足恢复和复制需要
		mysql的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
